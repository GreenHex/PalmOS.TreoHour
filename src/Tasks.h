/*
 * Tasks.h
 */

#ifndef __TASKS_H__
#define __TASKS_H__

#include <Hs.h>
#include <PalmOS.h>
#include <PalmTypes.h>
#include <SystemMgr.h>
#include <palmOneCreators.h>

#include "Utils.h"

/******************************************************************************
 * Copyright (c) 1995-2005 palmOne, Inc. or its subsidiaries.
 * All rights reserved.
 *****************************************************************************/
/**
 * @ingroup PIM
 */

/**
 * @file ToDoDB.h
 *
 * @brief Contains database record type and constants for Tasks application.
 *
 * Tasks application uses a different record format than the old ToDo
 * application due to some feature enhancement and new data fields. This file
 * contains the structure of the record in Tasks DB and can be used to access
 * the database directly. One way to utilize this header file is to combine it
 * with the old To Do source code so that the record packing and unpacking
 * routines are adjusted for the new structure.
 *
 * Please note that accessing the database directly is generally not recommended
 * and this is offered as a temporary solution for 3rd party developers. The
 * structure might change again in the future.
 *
 * <hr>
 */

#include <DataMgr.h>
#include <DateTime.h>

/** PalmSource ToDo app database version at time of change. */
#define TODO_DB_VERSION_CLASSIC 0

/** palmOne new Tasks app database version. */
#define TODO_DB_VERSION_MULLET  1

/** Current database version. */
#define TODO_DB_VERSION         TODO_DB_VERSION_MULLET

/** The app info string resource ID for localized strings to replace the
 *  strings in the application info block depending on the current
 *  system locale state (e.g.: Spanish). */
#define LocalizedAppInfoStr     1000

/**
 * @name Miscellaneous
 */
/*@{*/
#define todoLabelLength         12
#define todoNumFields           16
/*@}*/

/** Maximum priority value; range is 1 - toDoMaxPriority. */
#define toDoMaxPriority         5

/** Dirty flags for to do application info. */
#define toDoSortByPriorityDirty 0x0001

/**
 * @name Database Sort Orders
 */
/*@{*/
#define soDueDatePriority       0
#define soPriorityDueDate       1
#define soCategoryPriority      2
#define soCategoryDueDate       3
/*@}*/

/** @brief Application Info Block
 *
 * This structure is used to store info applicable to all records
 * in the database, specific to the application, inter-session (like
 * preferences), etc.
 */
typedef struct {

    /** Bitfield of categories with a different name */
    UInt16          renamedCategories;

    char            categoryLabels[dmRecNumCategories][dmCategoryLength];

    UInt8           categoryUniqIDs[dmRecNumCategories];

    /**
     * Uniq IDs generated by the device are between 0 - 127.  Those
     * from the PC are 128 - 255.
     */
    UInt8           lastUniqID;

    /** From the compiler word aligning things */
    UInt8           reserved1;

    /**
     * Whether category colors were edited since last sync.
     * Least significant bit first.
     */
    UInt16          categoryColorsEdited;

    /**
     * Added as part of the Mullet version of this application so that we can
     * later support color categories without breaking the conduits.
     */
    UInt8           categoryColors[dmRecNumCategories];

    UInt16          reserved2;

    UInt16          dirtyAppInfo;

    /** The database sort order. */
    UInt8           sortOrder;

    UInt8           reserved3;

} ToDoAppInfoType;

typedef ToDoAppInfoType * ToDoAppInfoPtr;

/***********************************************************************
 *  Application Record Format Related Data - CLASSIC
 ***********************************************************************/
#if TODO_DB_VERSION == TODO_DB_VERSION_CLASSIC

/***********************************************************************
 *  Application Packed Record Format Related Data
 *
 *  Note: Records are stored in the database in packed format to
 *        conserve space.  When creating a new record, ToDoNewRecord(),
 *        or saving a record, ToDoChangeRecord(), the packing is handled
 *        for you.
 ***********************************************************************/

/**
 * @brief   Record format
 *
 * This is the packed database record format; record format as
 * stored. All strings are null terminated and appear within
 * the record.
 */
typedef struct {
    DateType dueDate;
    UInt8 priority;     /**< high bit is complete flag */
    char description;   /**< start of the task description string */
} ToDoDBRecord;

typedef ToDoDBRecord            ToDoDBRecordType;
typedef ToDoDBRecord*           ToDoDBRecordPtr;

/**
 * @brief   Get the minimum size of the packed record.
 *
 * Minimum size assumes empty 'description' and 'note' fields.
 * An extra byte is calculated into the minimum size for the
 * NULL character of a note string.
 *
 * @return  Minimum size of the packed record.
 */
#define sizeDBRecord (sizeof (ToDoDBRecord) + 1)

/***********************************************************************
 *  Application Unpacked Record Format Related Data
 ***********************************************************************/

/**
 * @brief   Record format
 *
 * This is the unpacked record format as used by the app.  All
 * pointers are either NULL or point to data within the PackedDB
 * record.  All strings are NULL character terminated.
 */
typedef struct {
    DateType            dueDate;
    UInt8               priority;       /**< high bit is complete flag */
    UInt8               reserved;
    Char *              description;
    Char *              note;
} ToDoItemType;

typedef ToDoItemType * ToDoItemPtr;

/** Indicates a task record has been completed. */
#define completeFlag    0x80

/** Bit mask for checking the priority bits of the priority member. */
#define priorityOnly    ~completeFlag

/***********************************************************************
 *  Application Record Format Related Data - NEW PIM
 ***********************************************************************/
#elif TODO_DB_VERSION == TODO_DB_VERSION_MULLET

/**
 * @brief   Record data flags
 *
 * These flags indicate if a record contains specific data
 * features. e.g.: if the dueDate flag is set, then the record
 * has due date data.
 */
typedef struct {
    unsigned    dueDate         : 1;
    unsigned    completionDate  : 1;
    unsigned    alarm           : 1;
    unsigned    repeat          : 1;
    unsigned    description     : 1;
    unsigned    note            : 1;
    unsigned    reserved        : 10;
} ToDoDBDataFlags;

/***********************************************************************
 *  Application Unpacked Record Format Related Data
 ***********************************************************************/

/**
 * @brief   Record alarm data
 *
 * Records with due dates can have an alarm set for the due
 * date, and for each day preceding the due date as specified
 * by the number of days in advance of the due date that the
 * alarm should first occur.
 */
typedef struct {
    TimeType    alarmTime;
    UInt16      alarmAdvanceDays;
} ToDoAlarmInfoType;

typedef ToDoAlarmInfoType   *ToDoAlarmInfoPtr;

#ifndef _REPEAT_TYPE_
#define _REPEAT_TYPE_

/**
 * @brief   Repeating record frequency
 *
 * This enum is used to specify the frequency of
 * repeating appointments.
 */

enum repeatTypes {
    repeatNone,
    repeatDaily,
    repeatWeekly,
    repeatMonthlyByDay,
    repeatMonthlyByDate,
    repeatYearly
};

typedef enum repeatTypes RepeatType;

/**
 * @brief   Repeating task data.
 *
 * This structure contains information about repeat tasks.
 * The repeatOn member is only used by weekly and monthly-by-day
 * repeating tasks.
 *
 * For weekly the byte is a bit field that contains the days
 * of the week the for which the task is scheduled
 * (bit: 0-sun, 1-mon, 2-tue, etc.).
 * For monthly-by-day the byte contains the day for which
 * the task is scheduled, (ex: the 3rd friday), and the
 * byte is of type DayOfMonthType.
 */

typedef struct {
    RepeatType  repeatType;         /**< daily, weekly, monthlyByDay, etc. */
    UInt8       reserved1;
    DateType    repeatEndDate;      /**< minus one if forever */
    UInt8       repeatFrequency;    /**< i.e. every 2 days if repeatType daily
    */
    UInt8       repeatOn;           /**< monthlyByDay and repeatWeekly only */
    UInt8       repeatStartOfWeek;  /**< repeatWeekly only */
    UInt8       reserved2;
} RepeatInfoType;

typedef RepeatInfoType * RepeatInfoPtr;

#endif // _REPEAT_TYPE_

/**
 * @brief   Does the task repeat on only one day per week.
 *
 * The form (x & (x - 1)) masks out the lowest order bit
 * in x.  (K&R, p. 51)
 * If only one bit is set, which occurs iff the task is only
 * once per week, then (x & (x - 1)) == 0.
 *
 * @param R A repeat info type struct.
 *
 * @retval  True if the task repeats only once per week.
 */
#define OnlyRepeatsOncePerWeek(R)  (((R).repeatOn & ((R).repeatOn - 1)) == 0)

/**
 * @brief   Does the task repeat on the given day of the week.
 *
 * @param R Ptr to a repeat info type struct.
 * @param D The day of the week to check.
 *              For weekly repeating tasks, this
 *              is a bit field (see RepeatInfoType).
 *              For monthly-by-day repeating tasks,
 *              this is a DayOfMonthType.
 *
 * @retval  True if repeat info R repeats on day of week D.
 */
#define RepeatOnDOW(R, D)   ((1 << (D)) & ((R)->repeatOn))

/**
 * @brief   Task repeating data.
 */
typedef struct {
    DateType        repeatStartDate;
    RepeatInfoType  repeatInfo;
}
ToDoRepeatInfoType;

typedef ToDoRepeatInfoType  *ToDoRepeatInfoPtr;

/***********************************************************************
 *  Application Packed Record Format Related Data
 *
 *  Note: Records are stored in the database in packed format to
 *        conserve space.  When creating a new record, ToDoNewRecord(),
 *        or saving a record, ToDoChangeRecord(), the packing is handled
 *        for you.
 ***********************************************************************/

/**
 * @brief   Record format
 *
 * This is the packed database record format; record format
 * as stored.  All strings are null terminated and appear within
 * the record.
 *
 * optionalData is actually a variable-length compacted set
 * of optional data:
 *
 * if flags.dueDate, a DateType for the due date
 * then if flags.completionDate, a DateType for the completion date
 * then if flags.alarm, a TimeType (alarmTime) and a UInt16 (advance days)
 * then if flags.repeat, a DateType for the start date and a RepeatInfoType
 * then a null terminated description string
 * then a null terminated note string
 */
typedef struct {
    ToDoDBDataFlags dataFlags;
    UInt16          recordFlags;
    UInt16          priority;
    char            optionalData; // WARNING: it's an array
} ToDoDBRecord;

typedef ToDoDBRecord        ToDoDBRecordType;
typedef ToDoDBRecord*       ToDoDBRecordPtr;

/**
 * @brief   Get the minimum size of the packed record.
 *
 * Minimum size assumes all empty fields, which always includes
 * a NULL byte for a zero length description, and a NULL byte
 * for a zero length note.
 * This allows GetToDoDescriptionPtr and GetToDoNotePtr to always
 * return sensible values, and also allows FldSetText, etc. to
 * edit them directly.
 *
 * @return  Minimum size of the packed record.
 */
#define sizeDBRecord    (sizeof( ToDoDBRecord ) + 2)

/** @brief Record format
 *
 * This is the unpacked record format as used by the app.  All pointers
 * are either NULL or point to data allocated in the heap.  All
 * strings are NULL character terminated.
 */
typedef struct {
    ToDoDBDataFlags     dataFlags;
    UInt16              recordFlags;
    UInt16              priority;

    DateType            dueDate;

    DateType            completionDate;

    ToDoAlarmInfoType   alarmInfo;

    ToDoRepeatInfoType  repeatInfo;

    Char                *descriptionP;
    Char                *noteP;
} ToDoItemType;

typedef ToDoItemType * ToDoItemPtr;

/** Indicates a task record has been completed. */
#define TODO_RECORD_FLAG_COMPLETE           0x0001

/** Indicates that the next repeat date for the task should be based on the
 *  completion date of the task. i.e.: the next repeat date of the task
 *  will be the completion date plus the time of the repeat interval.
 *  e.g.: if the task was due yesterday, but not completed until today,
 *  and the repeat interval is 1 week, then the next due date of the task
 *  is 1 week from today instead of 1 week from yesterday.
 */
#define TODO_RECORD_FLAG_REPEAT_ON_COMPLETE 0x0002

#else
#error "Invalid TODO_DB_VERSION"
#endif

/**
 * @name Record Feature Negatives
 */
/*@{*/
#define toDoNoDueDate           0xffff
#define toDoNoCompletionDate    0xffff
#define toDoNoAlarmDate         0xffff
#define toDoNoAlarmTime         (noTime)
/*@}*/

/** Used for ToDoChangeRecord. */
typedef enum {
    toDoRecordFieldCategory,
    toDoRecordFieldDataFlags,
    toDoRecordFieldRecordFlags,
    toDoRecordFieldPriority,
    toDoRecordFieldComplete,
    toDoRecordFieldDueDate,
    toDoRecordFieldCompletionDate,
    toDoRecordFieldAlarm,
    toDoRecordFieldRepeat,
    toDoRecordFieldDescription,
    toDoRecordFieldNote,
    toDoRecordFieldEndOfRecord
} ToDoRecordFieldType;

#define TODO_FILTER_ALL					(0x0000)
#define TODO_FILTER_CATEGORY			(0x0001)
#define TODO_FILTER_DATE				(0x0002)

#define TODO_SUBFILTER_DATE_TODAY		(0x0000)
#define TODO_SUBFILTER_DATE_LAST_SEVEN	(0x0001)
#define TODO_SUBFILTER_DATE_NEXT_SEVEN	(0x0002)
#define TODO_SUBFILTER_DATE_PAST_DUE	(0x0003)

// Prototypes
extern UInt16 				GetNumTasks(DateType* pDate);

#endif /* __TASKS_H__ */

/*
 * Tasks.h
 */